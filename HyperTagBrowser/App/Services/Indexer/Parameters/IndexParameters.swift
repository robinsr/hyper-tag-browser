// created on 10/27/24 by robinsr

import CustomDump
import Defaults
import Foundation
import GRDB
import IdentifiedCollections
import OpenTelemetryApi
import System
import UniformTypeIdentifiers



// TODO: Better naming for this type. Suggesting `BrowseFilters` for the frontend, and `IndexRecordQueryParameters` for the backend
typealias BrowseFilters = IndxRequestParams


/**
 * Defines the parameters for a request to fetch IndexRecords from sqlite.
 */
struct IndxRequestParams: Codable, Identifiable, Copyable {
  
  /**
   * A unique identifier for the request, generated from the hash value of the parameters.
   */
  var id: String {
    get { self.hashId }
    set { self._nudge += 1 } // This will change the hash value, effectively changing the id
  }
  
  /**
   * Non-functional value only used to differentiate between requests
   */
  var _nudge: Int = 0
  
  /**
   * The base directory from which to search for IndexRecords. Items indexed above `rootDir`
   * are not returned. Items below are also not returned unless mode is recursive
   */
  @CodableFilePath var root: FilePath = Defaults[.profileOpenTo].filepath
  
  /**
   * A `ListMode` value determining whether to include only items in the root
   * directory or all items in the root directory and its subdirectories
   */
  var mode: ListMode = .immediate()
  
  /**
   * A set of `ContentTypeGroup` groups which expand to a set of `UTType` values
   */
  var types: [ContentTypeGroup] = [.user]
  
  /**
   * A `SortType` value determining how to sort the results
   */
  var sortBy: SortType = .initial
  
  /**
   * `FilteringTag` tags to filter on
   */
  var tagsMatching: FilteringTagMultiParam = .init([], operator: .and)
  
  /**
   * Text values to match against the IndexRecord `name` column
   */
  var nameMatching: StringValueMultiParam = .init([], operator: .and)
  
  /**
   * ContentId values to not include in query results
   */
  var excludeContent: StringValueMultiParam = .init([], operator: .and)
  
  /**
   * The maximum number of items to return
   */
  var limit: Int = Defaults[.photoGridItemLimit]
  
  /**
   * The offset from which to start returning items; used for pagination
   */
  var offset: Int = 0
  
  /**
   * The visibility state of the items to return (`normal`, `hidden`, or `either`)
   */
  var visibility: ContentItemVisibility = .normal
  
  /**
   * Flags that produce modified SQL queries for the request.
   */
  var options: [QueryOptions] = [.fileMustExist]
  
  /**
   * Columns generated by the query. By default, only the columns needed for
   * display as some column values are expensive to compute.
   */
  var includeColumns: [AdditionalColumns] = [ .tagCount, .fileExists, .isFolder ]
  
  /**
   * The sum total of all non-essential parameters, a zero number indicates a minimal query, untouched
   * from it's default state by the user.
   *
   * Essential parameters:
   * - Non-optional, single-value parameters (root, mode, types, sortBy, limit, offset, visibility)
   *
   * Non-essential parameters:
   *  - Tag Filters
   *  - Name Match Strings
   *  - Exclude Content Ids
   *  - Query Options
   *  - Include Columns
   */
  var filterCount: Int {
    tagsMatching.count + nameMatching.count
  }
  
  var isEmpty: Bool {
    filterCount == 0
  }
  
  
  /**
   * The current tag combination operator (Any or All) for the current query
   */
  var filterOperator: FilterOperator {
    tagsMatching.filterOpr
  }
  
  
  
  enum CodingKeys: String, CodingKey {
    case root, mode, types, visibility
    case tagsMatching, nameMatching, excludeContent
    case sortBy, limit, offset, options, includeColumns
  }
  
  
  enum QueryOptions: String, Codable {
      
    /// Flag to indicate that the query should include only items that exist on disk, and filter out those that do not
    case fileMustExist
  }
  
  
  enum AdditionalColumns: String, CaseIterable, Codable {
    case isFolder    // IndexRecord.Columns.isFolder,
    case fileExists  // IndexRecord.Columns.fileExists,
    case tagCount    // IndexRecord.Columns.tagCount,
    
    var selectAs: SQLExpression {
      switch self {
      case .isFolder: return IndexRecord.Selections.conforms(to: .folder)
      case .fileExists: return IndexRecord.Selections.fileExists
      case .tagCount: return IndexRecord.Selections.tagCount
      default:
        return Column(self.rawValue).sqlExpression
      }
    }
  }
  
  func clone() -> IndxRequestParams {
    var clone = self
    clone.id = .randomIdentifier(24)
    return clone
  }
  
  struct ParamConfigDefaults {
    static var contentItems: IndxRequestParams {
      .init(
        types: [.user],
        includeColumns: [.fileExists, .isFolder, .tagCount]
      )
    }
    
    static var contentItemCount: IndxRequestParams {
      .init(
        types: [.user],
        includeColumns: [.fileExists, .isFolder]
      )
    }
  }
  
  static let defaults = ParamConfigDefaults.self
}


// Conforming to Equatable allows for SwiftUI to detect changes (eg `.onChange(of: params)`)
extension IndxRequestParams: Equatable {
  static func == (lhs: IndxRequestParams, rhs: IndxRequestParams) -> Bool {
    return lhs.id == rhs.id
  }
}

extension IndxRequestParams: Hashable {
  func hash(into hasher: inout Hasher) {
    // Note: We do not hash `id` as it is a non-functional parameter
    hasher.combine(_nudge)
    hasher.combine(root.string)
    hasher.combine(mode.description)
    hasher.combine(types.map(\.rawValue).sorted())
    hasher.combine(sortBy.rawValue)
    hasher.combine(tagsMatching.hashValue)
    hasher.combine(nameMatching.hashValue)
    hasher.combine(excludeContent.hashValue)
    hasher.combine(limit)
    hasher.combine(offset)
    hasher.combine(visibility.rawValue)
    hasher.combine(options.map(\.rawValue).sorted())
    hasher.combine(includeColumns.map(\.rawValue).sorted())
  }
  
  var hashId: String {
    "\(self.hashValue)".hashId
  }
}


extension IndxRequestParams {
  
  typealias IndxCols = IndexRecord.Columns
  typealias ExtraCols = IndexRecord.VirtualColumns
  typealias IndxInfoCols = IndexInfoRecord.Columns
  typealias TagsCols = TagstringRecord.Columns
  
  var sqlSelections: [SQLSelectable] {
    let selections: [SQLSelectable] = IndexRecord.databaseSelection
    
    return AdditionalColumns.allCases.reduce(into: selections, { stmt, column in
      if includeColumns.contains(column) {
        stmt.append(column.selectAs.forKey(column.rawValue))
      }
    })
  }
  
  var sqlOrdering: SQLOrdering {
    sortBy.sqlOrdering
  }
  
  var filenameLike: SQLExpression {
    switch nameMatching.filterOpr {
    case .and:
      IndxCols.name.like(allOf: nameMatching.values)
    case .or:
      IndxCols.name.like(anyOf: nameMatching.values)
    }
  }
  
  var contentIdNotLike: SQLExpression {
    IndxCols.id.equals(noneOf: excludeContent.values)
  }
  
  var inclusiveTagValues: [String] {
    tagsMatching.inclusiveValues(inDomains: .attribution, .descriptive, .queue).tags.map(\.rawValue)
  }
  
  var exclusiveTagValues: [String] {
    tagsMatching.exclusiveValues(inDomains: .attribution, .descriptive, .queue).tags.map(\.rawValue)
  }
  
  var tagstringLike: SQLExpression {
    switch tagsMatching.filterOpr {
    case .and:
      TagsCols.tagString.like(allOf: inclusiveTagValues)
    case .or:
      TagsCols.tagString.like(anyOf: inclusiveTagValues)
    }
  }
  
  var tagstringNotLike: SQLExpression {
    TagsCols.tagString.like(noneOf: exclusiveTagValues)
  }
  
  var matchesTags: Bool {
    !inclusiveTagValues.isEmpty || !exclusiveTagValues.isEmpty
  }
  
  var visibilityLike: SQLExpression {
    IndxCols.visibility.equals(anyOf: visibility.acceptableValues.map(\.rawValue))
  }
  
  var locationLike: SQLExpression {
    switch mode {
    case .immediate:
      return [
        IndxCols.location.prefixed(like: root.string),
        IndxCols.location.prefixed(unlike: root.string + "/")
      ]
      .joined(operator: .and)
    
    case .recursive:
      return IndxCols.location.prefixed(like: root.string)
    }
  }
  
  var fileTypes: Set<UTType> {
    var filetypes = types.filetypes
    
    if mode.type == .recursive {
      filetypes = filetypes.subtracting([.folder, .directory])
    }
    
    return filetypes
  }
  
  var fileTypeIdentifies: [String] {
    fileTypes.map(\.identifier)
  }
  
  var fileTypeLike: SQLExpression {
    fileTypeIdentifies.isEmpty ? .any : IndxCols.type.equals(anyOf: fileTypeIdentifies)
  }
  
  /**
   * Time-based parameters for filtering IndexRecords
   */
  var datesMatching: FilteringTagMultiParam {
    let tagValues = self.tagsMatching.filters
    let tagOperator = self.tagsMatching.filterOpr
    
    let tags = tagValues.ofDomain(.creation)
    
    return FilteringTagMultiParam(tags, operator: tagOperator)
  }
  
  var creationBounds: [BoundedDate] {
    tagsMatching.inclusiveValues(inDomains: .creation).tags.compactMap(\.boundedDate)
  }
  
  var fileCreation: SQLExpression {
    if creationBounds.isEmpty {
      return .any
    }
    
    switch tagsMatching.filterOpr {
    case .and:
      return IndxCols.created.boundedBy(allOf: creationBounds)
    case .or:
      return IndxCols.created.boundedBy(anyOf: creationBounds)
    }
  }
}


extension IndxRequestParams {
  
  
    /// A FilterGroup for the ``TagDomain/descriptive`` tags to be inclusively applied
  var includingTags: FilteringTag.FilterGroup {
    .init(name: "Matching Tags", items: tagsMatching.inclusiveValues(inDomains: .descriptive))
  }
  
    /// A FilterGroup for the ``TagDomain/descriptive`` tags to be exclusively applied
  var excludingTags: FilteringTag.FilterGroup {
    .init(name: "Not Matching Tags", items: tagsMatching.exclusiveValues(inDomains: .descriptive))
  }
  
    /// A FilterGroup for the ``TagDomain/attribution`` tags to be inclusively applied
  var createdAtTags: FilteringTag.FilterGroup {
    .init(name: "Created At", items: tagsMatching.inclusiveValues(inDomains: .creation))
  }
  
  
    /// A FilterGroup for the ``TagDomain/attribution`` tags to be exclusively applied
  var notCreatedAtTags: FilteringTag.FilterGroup {
    .init(name: "Not Created At", items: tagsMatching.exclusiveValues(inDomains: .creation))
  }
  
    /// A FilterGroup for the ``TagDomain/queue`` tags to be inclusively applied
  var inqueueTags: FilteringTag.FilterGroup {
    .init(name: "In Queue", items: tagsMatching.inclusiveValues(inDomains: .queue))
  }
  
    /// A FilterGroup for the ``TagDomain/queue`` tags to be exclusively applied
  var notInqueueTags: FilteringTag.FilterGroup {
    .init(name: "Not In Queue", items: tagsMatching.exclusiveValues(inDomains: .queue))
  }
  
    /// A FilterGroup for the ``TagDomain/attribution`` tags to be inclusively applied
  var nameMatchingTags: FilteringTag.FilterGroup {
    .init(name: "Filename Like", items: tagsMatching.inclusiveValues(inDomains: .unlabled))
  }
  
    /// A FilterGroup for the ``TagDomain/attribution`` tags to be exclusively applied
  var nameNotMatchingTags: FilteringTag.FilterGroup {
    .init(name: "Filename Not Like", items: tagsMatching.exclusiveValues(inDomains: .unlabled))
  }
}


extension DerivableRequest<IndexRecord> {
  
  /**
   * Encodes the request parameters into the request.
   */
  func applyingParams(_ params: IndxRequestParams) -> Self {
    var request = self
    
    request = request
      .filter(params.locationLike)
      .filter(params.fileTypeLike)
      .filter(params.visibilityLike)
      .filter(params.fileCreation)
    
    if !params.excludeContent.isEmpty {
      request = request.filter(params.contentIdNotLike)
    }
    
    if !params.nameMatching.isEmpty {
      request = request.filter(params.filenameLike)
    }
    
    if params.matchesTags {
      let withMatchingTagsSubquery = CommonTableExpression(
          named: "contentIds",
          request: TagstringRecord
            .select(TagstringRecord.Columns.contentId)
            .filter(params.tagstringLike)
            .filter(params.tagstringNotLike)
      )
      
      request = request
        .with(withMatchingTagsSubquery)
        .filter(withMatchingTagsSubquery.contains(IndexRecord.Columns.id))
    }
    
    return request
  }
}


extension IndxRequestParams {
  
  
  /**
   * Returns a dictionary representation of the parameters for use in telemetry metrics.
   */
  var metricValues: AttributeValueMap {
    [
      "filterCount": .int(filterCount),
      "filterOperator": .string(tagsMatching.filterOpr.rawValue),
      "filterValues": .init(tagsMatching.filters.tagValues),
      "itemCount": .int(limit),
    ]
  }
}
